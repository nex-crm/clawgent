/**
 * CLAWGENT — Retro Arcade Sound Engine
 *
 * All sounds pre-generated as WAV files and played via HTMLAudioElement pools.
 * Each sound has 3 pre-created audio elements that round-robin on rapid calls,
 * eliminating the Web Audio API node-creation overhead that caused lag.
 *
 * WAV files live in /public/sounds/ and are generated by scripts/generate-sounds.mjs
 *
 * Usage:
 *   import { ArcadeSounds } from '@/lib/sounds';
 *   ArcadeSounds.initAudio();      // call on first user interaction
 *   ArcadeSounds.cursorMove();      // play a sound
 *   ArcadeSounds.toggleMute();      // toggle mute
 *   ArcadeSounds.isMuted();         // check mute state
 */

// ─── Constants ──────────────────────────────────────────────────────

const MASTER_VOLUME = 0.25;
const STORAGE_KEY = "clawgent-sound-muted";
const POOL_SIZE = 3;
const THROTTLE_MS = 40;

// ─── State ──────────────────────────────────────────────────────────

let muted = false;
let initialized = false;
let lastCursorMoveTime = 0;
let lastButtonHoverTime = 0;

// ─── Audio Pool ─────────────────────────────────────────────────────

interface SoundPool {
  elements: HTMLAudioElement[];
  index: number;
}

const SOUND_NAMES = [
  "cursor-move",
  "select",
  "back",
  "screen-transition",
  "deploy-start",
  "deploy-progress",
  "deploy-success",
  "deploy-error",
  "button-hover",
  "button-click",
  "destroy",
  "ttl-warning",
  "ttl-expired",
  "sign-in",
  "sign-out",
  "ko",
] as const;

type SoundName = (typeof SOUND_NAMES)[number];

const pools: Record<string, SoundPool> = {};

/**
 * Create a pool of HTMLAudioElement instances for a given sound file.
 * Pre-creates POOL_SIZE elements so rapid-fire calls round-robin
 * without waiting for a previous play to finish.
 */
function createPool(name: SoundName): SoundPool {
  const elements: HTMLAudioElement[] = [];
  for (let i = 0; i < POOL_SIZE; i++) {
    const audio = new Audio(`/sounds/${name}.wav`);
    audio.volume = MASTER_VOLUME;
    audio.preload = "auto";
    elements.push(audio);
  }
  return { elements, index: 0 };
}

/**
 * Play the next available element from a pool via round-robin.
 * Resets currentTime so the same element can restart immediately.
 */
function playPool(pool: SoundPool): void {
  if (muted || !pool.elements.length) return;
  const audio = pool.elements[pool.index];
  pool.index = (pool.index + 1) % pool.elements.length;
  audio.currentTime = 0;
  audio.play().catch(() => {
    // Autoplay blocked or audio not loaded yet — silently ignore
  });
}

/**
 * Update the volume on all pool elements. Called when mute toggles
 * or volume changes.
 */
function updateAllVolumes(): void {
  const vol = muted ? 0 : MASTER_VOLUME;
  for (const name of SOUND_NAMES) {
    const pool = pools[name];
    if (!pool) continue;
    for (const el of pool.elements) {
      el.volume = vol;
    }
  }
}

// ─── Public API ─────────────────────────────────────────────────────

export const ArcadeSounds = {
  /**
   * Initialize audio pools. Must be called from a user interaction
   * event handler (click/keydown) to satisfy browser autoplay policy.
   * Safe to call multiple times — subsequent calls are no-ops.
   */
  initAudio(): void {
    if (typeof window === "undefined") return;
    if (initialized) return;

    // Create all pools and start preloading
    for (const name of SOUND_NAMES) {
      pools[name] = createPool(name);
    }

    // Restore mute preference from localStorage
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved === "true") {
        muted = true;
        updateAllVolumes();
      }
    } catch {
      // localStorage unavailable
    }

    initialized = true;
  },

  /** Toggle mute on/off. Returns new muted state. */
  toggleMute(): boolean {
    muted = !muted;
    updateAllVolumes();
    try {
      localStorage.setItem(STORAGE_KEY, String(muted));
    } catch {
      // localStorage unavailable
    }
    return muted;
  },

  /** Check current mute state. */
  isMuted(): boolean {
    return muted;
  },

  // ─── Navigation ──────────────────────────────────────────────

  /** Short blip when hovering/selecting persona grid items. */
  cursorMove(): void {
    const now = performance.now();
    if (now - lastCursorMoveTime < THROTTLE_MS) return;
    lastCursorMoveTime = now;
    if (!pools["cursor-move"]) return;
    playPool(pools["cursor-move"]);
  },

  /** Confirmation beep when selecting a persona — two-tone ascending. */
  select(): void {
    if (!pools["select"]) return;
    playPool(pools["select"]);
  },

  /** Lower-pitched blip for going back. */
  back(): void {
    if (!pools["back"]) return;
    playPool(pools["back"]);
  },

  // ─── Screen transitions ──────────────────────────────────────

  /** Whoosh/sweep sound for screen changes. */
  screenTransition(): void {
    if (!pools["screen-transition"]) return;
    playPool(pools["screen-transition"]);
  },

  // ─── Deploy sequence ─────────────────────────────────────────

  /** Engine rev / power-up sound when deploy begins. */
  deployStart(): void {
    if (!pools["deploy-start"]) return;
    playPool(pools["deploy-start"]);
  },

  /** Subtle tick/pulse for each log line during deploy. */
  deployProgress(): void {
    if (!pools["deploy-progress"]) return;
    playPool(pools["deploy-progress"]);
  },

  /** Victory fanfare — C major arpeggio. */
  deploySuccess(): void {
    if (!pools["deploy-success"]) return;
    playPool(pools["deploy-success"]);
  },

  /** Sad trombone / error buzz — descending minor sequence. */
  deployError(): void {
    if (!pools["deploy-error"]) return;
    playPool(pools["deploy-error"]);
  },

  // ─── Actions ─────────────────────────────────────────────────

  /** Very subtle high-frequency tick on button hover. */
  buttonHover(): void {
    const now = performance.now();
    if (now - lastButtonHoverTime < THROTTLE_MS) return;
    lastButtonHoverTime = now;
    if (!pools["button-hover"]) return;
    playPool(pools["button-hover"]);
  },

  /** Satisfying click/confirm. */
  buttonClick(): void {
    if (!pools["button-click"]) return;
    playPool(pools["button-click"]);
  },

  /** Explosion/power-down sound for destroying an instance. */
  destroy(): void {
    if (!pools["destroy"]) return;
    playPool(pools["destroy"]);
  },

  // ─── TTL warnings ────────────────────────────────────────────

  /** Urgent beep — low-health warning, 440Hz square beeping. */
  ttlWarning(): void {
    if (!pools["ttl-warning"]) return;
    playPool(pools["ttl-warning"]);
  },

  /** "TIME OVER" sound — descending tone. */
  ttlExpired(): void {
    if (!pools["ttl-expired"]) return;
    playPool(pools["ttl-expired"]);
  },

  // ─── Auth ────────────────────────────────────────────────────

  /** Coin insert sound — classic arcade coin-op feel. */
  signIn(): void {
    if (!pools["sign-in"]) return;
    playPool(pools["sign-in"]);
  },

  /** Power down — descending sweep with decay. */
  signOut(): void {
    if (!pools["sign-out"]) return;
    playPool(pools["sign-out"]);
  },

  // ─── Fun ─────────────────────────────────────────────────────

  /** Classic KO impact for when "IT'S ALIVE" shows. */
  koSound(): void {
    if (!pools["ko"]) return;
    playPool(pools["ko"]);
  },
};
