name: CD

on:
  push:
    branches: [main]

concurrency:
  group: cd-production
  cancel-in-progress: false

jobs:
  ci-check:
    name: Lint & Build Gate
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: app

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          cache-dependency-path: app/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Lint
        run: npm run lint

      - name: Build
        run: npm run build

  deploy:
    name: Deploy to Production
    needs: ci-check
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 15
    permissions:
      id-token: write
      contents: read

    env:
      INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup SSM helper
        run: |
          cat > /tmp/ssm_run.sh << 'HELPER'
          # Usage: ssm_run <description> <timeout_seconds> <script>
          ssm_run() {
            local desc="$1" timeout="$2" script="$3"
            echo "=== $desc ==="
            local params
            params=$(jq -n --arg s "$script" \
              '{"commands": ($s | split("\n") | map(select(length > 0)))}')
            local cmd_id
            cmd_id=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --comment "$desc" \
              --timeout-seconds "$timeout" \
              --parameters "$params" \
              --output text \
              --query 'Command.CommandId') || { echo "Failed to send SSM command" >&2; return 1; }
            if [ -z "$cmd_id" ]; then
              echo "No command ID returned from SSM" >&2; return 1
            fi
            echo "SSM command: $cmd_id"
            local elapsed=0
            while [ "$elapsed" -lt "$timeout" ]; do
              local inv
              inv=$(aws ssm get-command-invocation \
                --command-id "$cmd_id" \
                --instance-id "$INSTANCE_ID" 2>/dev/null || true)
              if [ -z "$inv" ]; then
                sleep 5; elapsed=$((elapsed + 5)); continue
              fi
              local status
              status=$(printf '%s' "$inv" | jq -r '.StatusDetails')
              case "$status" in
                Success)
                  printf '%s' "$inv" | jq -r '.StandardOutputContent'
                  return 0
                  ;;
                Failed|Cancelled|TimedOut|Undeliverable|Terminated)
                  printf '%s' "$inv" | jq -r '.StandardOutputContent'
                  printf '%s' "$inv" | jq -r '.StandardErrorContent' >&2
                  echo "Command failed: $status" >&2
                  return 1
                  ;;
                *)
                  echo "[${elapsed}s] $status..."
                  sleep 5; elapsed=$((elapsed + 5))
                  ;;
              esac
            done
            echo "Timed out after ${timeout}s" >&2
            return 1
          }
          HELPER

      - name: Backup SQLite database
        run: |
          source /tmp/ssm_run.sh
          ssm_run "Backup database" 120 '
          set -euo pipefail
          BACKUP_DIR="/opt/clawgent/backups"
          DB_PATH="/opt/clawgent/app/data/clawgent.db"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          mkdir -p "$BACKUP_DIR"
          if [ -f "$DB_PATH" ]; then
            echo "Backing up database to ${BACKUP_DIR}/clawgent_${TIMESTAMP}.db"
            sqlite3 "$DB_PATH" ".backup ${BACKUP_DIR}/clawgent_${TIMESTAMP}.db"
            echo "Backup complete"
            cd "$BACKUP_DIR"
            ls -1t clawgent_*.db 2>/dev/null | tail -n +11 | xargs -r rm -f
            echo "Retained backups:"
            ls -1t clawgent_*.db 2>/dev/null
          else
            echo "No database found at ${DB_PATH} — skipping backup (first deploy)"
          fi'

      - name: Upload app to S3
        run: |
          aws s3 sync app/ s3://${{ secrets.S3_DEPLOY_BUCKET }}/deploy/ \
            --delete \
            --exclude ".git/*" \
            --exclude "node_modules/*" \
            --exclude ".next/*" \
            --exclude ".env.local" \
            --exclude ".env.production" \
            --exclude "data/*" \
            --exclude ".DS_Store"
          aws s3 cp deploy/ecosystem.config.js \
            s3://${{ secrets.S3_DEPLOY_BUCKET }}/deploy-config/ecosystem.config.js

      - name: Sync app from S3 on server
        run: |
          source /tmp/ssm_run.sh
          ssm_run "Sync app from S3" 120 '
          set -euo pipefail
          aws s3 sync s3://${{ secrets.S3_DEPLOY_BUCKET }}/deploy/ /opt/clawgent/app/ --delete
          aws s3 cp s3://${{ secrets.S3_DEPLOY_BUCKET }}/deploy-config/ecosystem.config.js \
            /opt/clawgent/ecosystem.config.js
          echo "Files synced from S3"'

      - name: Pull OpenClaw Docker image
        run: |
          source /tmp/ssm_run.sh
          ssm_run "Pull OpenClaw Docker image" 300 '
          set -euo pipefail
          OPENCLAW_VERSION="2026.2.23"
          echo "Pulling OpenClaw ${OPENCLAW_VERSION} from ghcr.io..."
          docker pull "ghcr.io/openclaw/openclaw:${OPENCLAW_VERSION}"
          docker tag "ghcr.io/openclaw/openclaw:${OPENCLAW_VERSION}" clawgent-openclaw
          echo "OpenClaw image ready:"
          docker images clawgent-openclaw'

      - name: Write .env.local from secrets
        env:
          WORKOS_CLIENT_ID: ${{ secrets.WORKOS_CLIENT_ID }}
          WORKOS_API_KEY: ${{ secrets.WORKOS_API_KEY }}
          WORKOS_COOKIE_PASSWORD: ${{ secrets.WORKOS_COOKIE_PASSWORD }}
          PLIVO_AUTH_ID: ${{ secrets.PLIVO_AUTH_ID }}
          PLIVO_AUTH_TOKEN: ${{ secrets.PLIVO_AUTH_TOKEN }}
          PLIVO_WHATSAPP_NUMBER: ${{ secrets.PLIVO_WHATSAPP_NUMBER }}
        run: |
          source /tmp/ssm_run.sh
          # Base64-encode the env file so it can be safely embedded in the SSM command
          B64_ENV=$(printf '%s\n' \
            "WORKOS_CLIENT_ID=$WORKOS_CLIENT_ID" \
            "WORKOS_API_KEY=$WORKOS_API_KEY" \
            "WORKOS_COOKIE_PASSWORD=$WORKOS_COOKIE_PASSWORD" \
            "NEXT_PUBLIC_WORKOS_REDIRECT_URI=https://clawgent.ai/auth/callback" \
            "NODE_ENV=production" \
            "PORT=3001" \
            "PLIVO_AUTH_ID=$PLIVO_AUTH_ID" \
            "PLIVO_AUTH_TOKEN=$PLIVO_AUTH_TOKEN" \
            "PLIVO_WHATSAPP_NUMBER=$PLIVO_WHATSAPP_NUMBER" \
            "PLIVO_WEBHOOK_URL=https://clawgent.ai/api/whatsapp/webhook" \
            | base64 -w 0)
          ssm_run "Write .env.local" 30 \
            "printf '%s' '${B64_ENV}' | base64 -d > /opt/clawgent/app/.env.local && chmod 600 /opt/clawgent/app/.env.local && echo '.env.local written successfully'"

      - name: Install dependencies and build on server
        run: |
          source /tmp/ssm_run.sh
          ssm_run "Install deps and build" 600 '
          set -euo pipefail
          cd /opt/clawgent/app
          npm ci --production=false
          npm run build'

      - name: Reload PM2
        run: |
          source /tmp/ssm_run.sh
          ssm_run "Reload PM2" 60 '
          set -euo pipefail
          cd /opt/clawgent
          if pm2 reload ecosystem.config.js --update-env 2>/dev/null; then
            echo "PM2 reload succeeded"
          else
            echo "PM2 reload failed — falling back to delete + start"
            pm2 delete clawgent 2>/dev/null || true
            pm2 start ecosystem.config.js
          fi
          pm2 save'

      - name: Health check
        run: |
          source /tmp/ssm_run.sh
          ssm_run "Health check" 120 '
          set -euo pipefail
          MAX_ATTEMPTS=15
          INTERVAL=4
          URL="http://localhost:3001/api/status"
          echo "Polling ${URL} (max ${MAX_ATTEMPTS} attempts, ${INTERVAL}s apart)..."
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt ${i}/${MAX_ATTEMPTS}..."
            HTTP_CODE=$(curl -s -o /tmp/health_response.json -w "%{http_code}" "$URL" 2>/dev/null || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "HTTP 200 received"
              cat /tmp/health_response.json
              DOCKER_AVAILABLE=$(python3 -c "import sys,json; print(json.load(open('/tmp/health_response.json')).get('dockerAvailable', False))" 2>/dev/null || echo "false")
              if [ "$DOCKER_AVAILABLE" = "True" ] || [ "$DOCKER_AVAILABLE" = "true" ]; then
                echo "Health check PASSED — app is up and Docker is available"
              else
                echo "WARNING: App is responding but dockerAvailable=${DOCKER_AVAILABLE}"
                echo "Health check PASSED with warning — app is up but Docker may not be available"
              fi
              exit 0
            fi
            echo "Got HTTP ${HTTP_CODE}, retrying in ${INTERVAL}s..."
            sleep $INTERVAL
          done
          echo "::error::Health check FAILED after ${MAX_ATTEMPTS} attempts"
          echo "=== PM2 Status ==="
          pm2 status
          echo "=== PM2 Logs (last 50 lines) ==="
          pm2 logs clawgent --nostream --lines 50 || true
          exit 1'

      - name: Rollback on failure
        if: failure()
        run: |
          source /tmp/ssm_run.sh
          ssm_run "Rollback" 120 '
          set -euo pipefail
          BACKUP_DIR="/opt/clawgent/backups"
          DB_PATH="/opt/clawgent/app/data/clawgent.db"
          echo "=== ROLLBACK: Attempting to restore latest database backup ==="
          LATEST_BACKUP=$(ls -1t "${BACKUP_DIR}"/clawgent_*.db 2>/dev/null | head -1 || true)
          if [ -n "$LATEST_BACKUP" ]; then
            echo "Restoring from: ${LATEST_BACKUP}"
            mkdir -p "$(dirname "$DB_PATH")"
            cp "$LATEST_BACKUP" "$DB_PATH"
            echo "Database restored"
          else
            echo "No backups found to restore"
          fi
          echo "Restarting PM2..."
          cd /opt/clawgent
          pm2 restart clawgent 2>/dev/null || pm2 start ecosystem.config.js 2>/dev/null || true
          pm2 save 2>/dev/null || true
          echo ""
          echo "=== MANUAL INTERVENTION MAY BE REQUIRED ==="
          echo "1. Check PM2 logs: pm2 logs clawgent"
          echo "2. Check app status: curl http://localhost:3001/api/status"
          echo "3. If needed, redeploy previous commit manually"
          echo "4. Database backups in: ${BACKUP_DIR}/"'
